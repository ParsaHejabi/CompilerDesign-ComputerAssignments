/* Package and import specifications */
import ASTNodes.*;
import ASTNodes.Enums.*;
import ASTNodes.Interfaces.*;

/* Parser class name */
class Parser;

/* Terminals (tokens returned by the scanner). */
// const_val terminals
terminal    Integer         INT_CONST;
terminal    Double          REAL_CONST;
terminal    Character       CHAR_CONST;
terminal    Boolean         BOOL_CONST;
terminal    String          STRING_CONST;
terminal    Long            LONG_CONST;

// conditional terminals
terminal                    EQUAL_TO, NOT_EQUAL_TO, GREATER_THAN_EQUAL_TO, LESS_THAN_EQUAL_TO, LESS_THAN, GREATER_THAN;
terminal                    AND_COND, OR_COND;

// arithmatic terminals
terminal                    PLUS, MINUS, TIMES, DIVIDE, MOD, AND_BITWISE, OR_BITWISE, XOR_BITWISE;

// variable terminals
terminal    String          IDENTIFIER;
terminal                    LBRACKET, RBRACKET;
terminal                    DOT;
/* TODO CHECK IF THESE TERMINALS SHOULD BE TWO OR FOUR */
terminal                    PREFIX_PLUS_PLUS, PREFIX_MINUS_MINUS;
terminal                    POSTFIX_PLUS_PLUS, POSTFIX_MINUS_MINUS;

// expr terminals
terminal                    LPAREN, RPAREN;
terminal                    MINUS_UNARY;
/* This not is bitwise negation */
terminal                    TILDE;
/* This not output is boolean */
terminal                    NOT_EXPR;
terminal                    SIZE_OF;

// loop_stmt terminals
terminal                    FOR, SEMICOLON;
terminal                    REPEAT, UNTIL;
terminal                    FOREACH, IN;

// cond_stmt terminals
terminal                    IF, ELSE;
terminal                    SWITCH, OF, COLON, BEGIN, CASE, DEFAULT, END;

// parameters terminals
terminal                    COMMA;

// assignment terminals
terminal                    EQUAL, PLUS_EQUAL, MINUS_EQUAL, TIMES_EQUAL, DIVIDE_EQUAL;

// statement terminals
terminal                    RETURN, BREAK, CONTINUE;

// var_dcl terminals
terminal                    CONST;

// struct_dec terminals
terminal                    RECORD;

// type terminals
terminal                    INT, BOOL, FLOAT, LONG, CHAR, DOUBLE, STRING, VOID, AUTO;

// extern_dcl terminals
terminal                    EXTERN;

// func_dcl terminals
terminal                    FUNCTION;

/* Non terminals */
// Main nonterminals
nonterminal     Program     program;
nonterminal     VarDcl      var_dcl;
nonterminal                 func_extern, struct_dec;
nonterminal     Type        type;
nonterminal     VarDclCnt   var_dcl_cnt;
nonterminal     Expr        expr;
nonterminal                 binary_op, method_call, variable, const_val;
nonterminal                 arithmatic, conditional;
nonterminal                 parameters;
nonterminal     FuncDcl     func_dcl;
nonterminal     ExternDcl   extern_dcl;
nonterminal     Arguments   arguments;
nonterminal                 block;
nonterminal                 statement;
nonterminal                 assignment, cond_stmt, loop_stmt;

// Plus nonterminals
nonterminal                 brack_expr_plus;
nonterminal     VarDcls     var_dcl_plus;

// Star nonterminals
nonterminal VarDclCnts      comma_var_dcl_cnt_star;
nonterminal                 var_dcl_or_statement_star;
nonterminal                 case_block_star;

// Optional nonterminals
nonterminal                 l_r_brace_optional;
nonterminal                 else_block_optional;
nonterminal                 assignment_optional;
nonterminal                 assignment_or_expr_optional;

/* Precedences */
precedence left             COMMA;
precedence right            TIMES_EQUAL, DIVIDE_EQUAL, PLUS_EQUAL, MINUS_EQUAL, EQUAL;
precedence left             OR_COND;
precedence left             AND_COND;
precedence left             OR_BITWISE;
precedence left             XOR_BITWISE;
precedence left             AND_BITWISE;
precedence left             EQUAL_TO, NOT_EQUAL_TO;
precedence left             GREATER_THAN, GREATER_THAN_EQUAL_TO, LESS_THAN, LESS_THAN_EQUAL_TO;
precedence left             PLUS, MINUS;
precedence left             TIMES, DIVIDE, MOD;
precedence right            PREFIX_PLUS_PLUS, PREFIX_MINUS_MINUS, SIZE_OF, NOT_EXPR, TILDE, MINUS_UNARY;
precedence nonassoc         LBRACKET, RBRACKET, LPAREN, RPAREN;
precedence left             POSTFIX_PLUS_PLUS, POSTFIX_MINUS_MINUS, DOT;

/* The grammar */
start with program;
program                     ::=     var_dcl:vd program:p
                                    {:
                                        if (p == null) {
                                            p = new Program();
                                        }
                                        p.addElement(vd);
                                        RESULT = p;
                                    :}
                                    |
                                    func_extern:fe program:p
                                    {:
                                        if (p == null) {
                                            p = new Program();
                                        }
                                        p.addElement(fe);
                                        RESULT = p;
                                    :}
                                    |
                                    struct_dec:sd program:p
                                    {:
                                        if (p == null) {
                                            p = new Program();
                                        }
                                        p.addElement(sd);
                                        RESULT = p;
                                    :}
                                    |
                                    {:
                                        RESULT = new Program();
                                    :}
                                    ;

func_extern                 ::=     func_dcl:fd
                                    {:
                                        RESULT = fd;
                                    :}
                                    |
                                    extern_dcl:ed
                                    {:
                                        RESULT = ed;
                                    :}
                                    ;

func_dcl                    ::=     FUNCTION type:t IDENTIFIER:i LPAREN arguments:a RPAREN SEMICOLON
                                    {:
                                        RESULT = new FuncDcl(t, i, a, FuncDclEnum.DECLARE);
                                    :}
                                    |
                                    FUNCTION type:t IDENTIFIER:i LPAREN RPAREN SEMICOLON
                                    {:
                                        RESULT = new FuncDcl(t, i, null, FuncDclEnum.DECLARE);
                                    :}
                                    |
                                    FUNCTION type:t IDENTIFIER:i LPAREN arguments:a RPAREN block
                                    {:
                                        RESULT = new FuncDcl(t, i, a, FuncDclEnum.DEFINE);
                                    :}
                                    |
                                    FUNCTION type:t IDENTIFIER:i LPAREN RPAREN block:b
                                    {:
                                        RESULT = new FuncDcl(t, i, null, FuncDclEnum.DEFINE);
                                    :}
                                    ;

extern_dcl                  ::=     EXTERN type:t IDENTIFIER:i SEMICOLON
                                    {:
                                        RESULT = new ExternDcl(t, i);
                                    :}
                                    ;

arguments                   ::=     type:t IDENTIFIER:i l_r_brace_optional COMMA arguments:a
                                    {:
                                        if (a == null) {
                                            a = new Arguments();
                                        }

                                        a.addElement(new Argument(t, i));
                                        RESULT = a;
                                    :}
                                    |
                                    type:t IDENTIFIER:i l_r_brace_optional
                                    {:
                                        Arguments a = new Arguments();
                                        a.addElement(new Argument(t, i));
                                        RESULT = a;
                                    :}
                                    ;

l_r_brace_optional          ::=     LBRACKET RBRACKET l_r_brace_optional
                                    {:
                                    :}
                                    |
                                    {:
                                    :}
                                    ;

type                        ::=     INT
                                    {:
                                        RESULT = new Type(TypeEnum.INT);
                                    :}
                                    |
                                    BOOL
                                    {:
                                        RESULT = new Type(TypeEnum.BOOL);
                                    :}
                                    |
                                    FLOAT
                                    {:
                                        RESULT = new Type(TypeEnum.FLOAT);
                                    :}
                                    |
                                    LONG
                                    {:
                                        RESULT = new Type(TypeEnum.LONG);
                                    :}
                                    |
                                    CHAR
                                    {:
                                        RESULT = new Type(TypeEnum.CHAR);
                                    :}
                                    |
                                    DOUBLE
                                    {:
                                        RESULT = new Type(TypeEnum.DOUBLE);
                                    :}
                                    |
                                    IDENTIFIER
                                    {:
                                        RESULT = new Type(TypeEnum.IDENTIFIER);
                                    :}
                                    |
                                    STRING
                                    {:
                                        RESULT = new Type(TypeEnum.STRING);
                                    :}
                                    |
                                    VOID
                                    {:
                                        RESULT = new Type(TypeEnum.VOID);
                                    :}
                                    |
                                    AUTO
                                    {:
                                        RESULT = new Type(TypeEnum.AUTO);
                                    :}
                                    ;

struct_dec                  ::=     RECORD IDENTIFIER:i BEGIN var_dcl_plus:vdp END SEMICOLON
                                    {:
                                        RESULT = new StructDcl(i, vdp);
                                    :}
                                    ;

var_dcl                     ::=     CONST type:t var_dcl_cnt:vdc comma_var_dcl_cnt_star:cvdcs SEMICOLON
                                    {:
                                        if (cvdcs == null) {
                                            cvdcs = new VarDclCnts();
                                        }
                                        cvdcs.addElement(vdc);
                                        RESULT = new VarDcl(true, t, cvdcs);
                                    :}
                                    |
                                    type:t var_dcl_cnt:vdc comma_var_dcl_cnt_star:cvdcs SEMICOLON
                                    {:
                                        if (cvdcs == null) {
                                            cvdcs = new VarDclCnts();
                                        }
                                        cvdcs.addElement(vdc);
                                        RESULT = new VarDcl(false, t, cvdcs);
                                    :}
                                    ;

var_dcl_plus                ::=     var_dcl:vd
                                    {:
                                        RESULT = new VarDcls();
                                        RESULT.addElement(vd);
                                    :}
                                    |
                                    var_dcl:vd var_dcl_plus:vdp
                                    {:
                                        if (vdp == null) {
                                            vdp = new VarDcls();
                                        }
                                        vdp.addElement(vd);
                                        RESULT = vdp;
                                    :}
                                    ;

comma_var_dcl_cnt_star      ::=     COMMA var_dcl_cnt:vdc comma_var_dcl_cnt_star:cvdcs
                                    {:
                                        if (cvdcs == null) {
                                            cvdcs = new VarDclCnts();
                                        }
                                        cvdcs.addElement(vdc);
                                        RESULT = cvdcs;
                                    :}
                                    |
                                    {:
                                    :}
                                    ;

var_dcl_cnt                 ::=     IDENTIFIER:i
                                    {:
                                        RESULT = new VarDclCnt(i, null);
                                    :}
                                    |
                                    IDENTIFIER:i EQUAL expr:e
                                    {:
                                        RESULT = new VarDclCnt(i, e);
                                    :}
                                    ;

block                       ::=     BEGIN var_dcl_or_statement_star:vdoss END
                                    {:
                                        Block b = new Block();
                                        b.varDcls_statements = vdoss;
                                        RESULT = b;
                                    :}
                                    ;

var_dcl_or_statement_star   ::=     var_dcl:vd var_dcl_or_statement_star:vdoss
                                    {:
                                        if (vdoss == null) {
                                            vdoss = new ArrayList<Object>();
                                        }
                                        vdoss.add(vd);
                                        RESULT = vdoss;
                                    :}
                                    |
                                    statement:s var_dcl_or_statement_star:vdoss
                                    {:
                                        if (vdoss == null) {
                                            vdoss = new ArrayList<Object>();
                                        }
                                        vdoss.add(vd);
                                        RESULT = vdoss;
                                    :}
                                    |
                                    {:
                                        RESULT = new ArrayList<Object>();
                                    :}
                                    ;

statement                   ::=     assignment SEMICOLON
                                    |
                                    method_call SEMICOLON
                                    |
                                    cond_stmt
                                    |
                                    loop_stmt
                                    |
                                    RETURN expr SEMICOLON
                                    |
                                    RETURN SEMICOLON
                                    |
                                    BREAK SEMICOLON
                                    |
                                    CONTINUE SEMICOLON
                                    ;

assignment                  ::=     variable EQUAL expr
                                    |
                                    variable PLUS_EQUAL expr
                                    |
                                    variable MINUS_EQUAL expr
                                    |
                                    variable TIMES_EQUAL expr
                                    |
                                    variable DIVIDE_EQUAL expr
                                    ;

method_call                 ::=     IDENTIFIER LPAREN parameters RPAREN
                                    |
                                    IDENTIFIER LPAREN RPAREN
                                    ;

parameters                  ::=     expr
                                    |
                                    expr COMMA parameters
                                    ;

cond_stmt                   ::=     IF LPAREN expr RPAREN block else_block_optional
                                    |
                                    SWITCH LPAREN IDENTIFIER RPAREN OF COLON BEGIN case_block_star DEFAULT COLON block END
                                    ;

else_block_optional         ::=     ELSE block
                                    |
                                    ;

case_block_star             ::=     CASE INT_CONST COLON block case_block_star
                                    |
                                    ;

loop_stmt                   ::=     FOR LPAREN assignment_optional SEMICOLON expr SEMICOLON assignment_or_expr_optional RPAREN block
                                    |
                                    REPEAT block UNTIL LPAREN expr RPAREN SEMICOLON
                                    |
                                    FOREACH LPAREN IDENTIFIER IN IDENTIFIER RPAREN block
                                    ;

assignment_optional         ::=     assignment
                                    |
                                    ;

assignment_or_expr_optional ::=     assignment
                                    |
                                    expr
                                    |
                                    ;

expr                        ::=     expr binary_op expr
                                    |
                                    LPAREN expr RPAREN
                                    |
                                    method_call
                                    |
                                    variable
                                    |
                                    const_val
                                    |
                                    MINUS_UNARY expr
                                    |
                                    TILDE expr
                                    |
                                    NOT_EXPR expr
                                    |
                                    SIZE_OF LPAREN type RPAREN
                                    ;

variable                    ::=     IDENTIFIER
                                    |
                                    IDENTIFIER LBRACKET expr RBRACKET brack_expr_plus
                                    |
                                    variable DOT IDENTIFIER
                                    |
                                    PREFIX_MINUS_MINUS variable
                                    |
                                    PREFIX_PLUS_PLUS variable
                                    |
                                    variable POSTFIX_MINUS_MINUS
                                    |
                                    variable POSTFIX_PLUS_PLUS
                                    ;

brack_expr_plus             ::=     LBRACKET expr RBRACKET brack_expr_plus
                                    |
                                    ;

binary_op                   ::=     arithmatic
                                    |
                                    conditional
                                    ;

arithmatic                  ::=     PLUS
                                    |
                                    MINUS
                                    |
                                    TIMES
                                    |
                                    DIVIDE
                                    |
                                    MOD
                                    |
                                    AND_BITWISE
                                    |
                                    OR_BITWISE
                                    |
                                    XOR_BITWISE
                                    ;

conditional                 ::=     EQUAL_TO
                                    |
                                    NOT_EQUAL_TO
                                    |
                                    GREATER_THAN_EQUAL_TO
                                    |
                                    LESS_THAN_EQUAL_TO
                                    |
                                    LESS_THAN
                                    |
                                    GREATER_THAN
                                    |
                                    AND_COND
                                    |
                                    OR_COND
                                    ;

const_val                   ::=     INT_CONST:i
                                    {:
                                        RESULT = new ConstValue(TypeEnum.INT, i);
                                    :}
                                    |
                                    REAL_CONST:i
                                    {:
                                        RESULT = new ConstValue(TypeEnum.DOUBLE, i);
                                    :}
                                    |
                                    CHAR_CONST:i
                                    {:
                                        RESULT = new ConstValue(TypeEnum.CHAR, i);
                                    :}
                                    |
                                    BOOL_CONST:i
                                    {:
                                        RESULT = new ConstValue(TypeEnum.BOOL, i);
                                    :}
                                    |
                                    STRING_CONST
                                    {:
                                        RESULT = new ConstValue(TypeEnum.STRING, i);
                                    :}
                                    |
                                    LONG_CONST
                                    {:
                                        RESULT = new ConstValue(TypeEnum.LONG, i);
                                    :}
                                    ;